{
  "hash": "e05d2b369f3153b93d9e080481341453",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2\"\n---\n\n\n\n\nokay so first comes the recreation of https://github.com/norvig/pytudes/blob/main/ipynb/Economics.ipynb#js-repo-pjax-container\n\n-   for this I used AI (chatGPT) to clarify parts of the python code I didn't understand - and asked it to explain to me how I could generate a population in R,\n\n-   for how generating a gini coefficient in R works - I looked at this tutorial (https://scales.arabpsychology.com/stats/how-to-calculate-gini-coefficient-in-r-with-example/) - using the inequality package in R. Unfortunatly the package is not supportted with the newest R version, so I asked chatGPT for alternatives. The suggestion was to create a custom gini() function\n\n-   I encountered some problems as the wealth included zeros/NA, i searched for help and found resources at [R Stackoverflow](https://stackoverflow.com/questions/tagged/r)Â and had to exclude 0's. For the simulation step I also asked chatGPT for help and had to adapt the code it generated / same for the simulation visualization (not the histograms) - I hope this gives enough credits, I would have been lost without it\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n#Parameters\n\nN <- 5000        #Default size of the population\n\nMU <- 100        #Default mean of the population\n\nsigma <- MU / 5  #Standard deviation is 1/5 of the mean\n\n#Generate the population\n\npopulation <- rnorm(N, mean = MU, sd = sigma)\npopulation[population <= 0] <- 1\n\n#Create gini function\n\ngini <- function(y) {\n  y <- sort(y)     #Sort pop by wealth in asending order \n  n <- length(y)   #Number of people\n  numer <- 2 * sum((1:n) * y)  #Numerator sum of sorted values weighted by list pos\n  denom <- n * sum(y)  #Denominator total wealth of pop\n    return((numer / denom) - (n + 1) / n) #Compute gini coeffi\n}\n\n# Print initial Gini coefficient\ncat(\"Initial Gini coefficient:\", gini(population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitial Gini coefficient: 0.1121553 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Create hist of pop\n\nlibrary(ggplot2)\n\nhist_pop <- function(population, label='Population') {\n  gini_value <- round(gini(population), 2)\n  label <- paste(label, \"- Gini =\", gini_value)\n  \n  p <- ggplot(data.frame(population), aes(x = population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = label, x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(p)  \n}\n\nhist_pop(population)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Transaction: Randomly split the pot between two actors\nrandom_split <- function(A, B) {\n  pot <- A + B\n  if (A <= 0 && B <= 0) return(c(0, 0))\n  share <- runif(1, 0, pot)\n  return(c(share, pot - share))\n}\n\n# Randomly select two actors\nanyone <- function(N) sample(1:N, 2)\n\n# Simulation step: Perform one transaction between two random actors\nstep_function <- function(population) {\n  indices <- anyone(length(population))\n  population[indices] <- random_split(population[indices[1]], population[indices[2]])\n  return(population)\n}\n\n# Simulate over T steps\nsimulate <- function(population, T) {\n  for (t in 1:T) {\n    population <- step_function(population)\n  }\n  return(population)\n}\n\n# Run the simulation and visualize the results\nT <- 1000  # Number of steps\nfinal_population <- simulate(population, T)\n\n# Plot final population distribution\nhist_pop(final_population, \"Final Population\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Display final Gini coefficient\ncat(\"Final Gini coefficient:\", gini(final_population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFinal Gini coefficient: 0.2120456 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Simulation Visualization\n\n# Libraries\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\n# Percentile Calculation & Results at interbvals\npercent <- function(pct, items) {\n  return(quantile(items, probs = pct / 100))\n}\n\nsimulate_collect <- function(population, T) {\n  results <- list()\n  for (t in 1:T) {\n    population <- step_function(population)\n    if (t %% (T / 10) == 0) {\n      results[[length(results) + 1]] <- list(t = t, pop = sort(population))\n    }\n  }\n  return(results)\n}\n\n#Simulation Visualization Function\nshow_simulation <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n  N <- length(population)\n  T <- k * N\n  start_population <- population\n  results <- simulate_collect(population, T)\n  \n  \n  cat(sprintf(\"%7s %6s %6s\", \"t\", \"Gini\", \"stdev\"))\n  for (pct in percentiles) {\n    cat(sprintf(\" %4d%%\", pct))\n  }\n  cat(\"\\n\")\n  cat(\"------- ------ ------\")\n  for (i in percentiles) cat(\" ----\")\n  cat(\"\\n\")\n  \n  for (result in results) {\n    pop <- result$pop\n    gini_value <- gini(pop)\n    stdev_value <- sd(pop)\n    percentile_values <- sapply(percentiles, function(pct) percent(pct, pop))\n    \n    \n    fmt <- sprintf(\"%7d %.2f %6.1f\", result$t, gini_value, stdev_value)\n    cat(fmt)\n    cat(sprintf(\"%4.0f\", percentile_values), \"\\n\")\n  }\n  \n  #Percentile plots over time\n  times <- sapply(results, function(res) res$t)\n  plot_data <- data.frame(\n    time = rep(times, each = length(percentiles)),\n    percentile = rep(percentiles, times = length(times)),\n    value = unlist(lapply(results, function(res) sapply(percentiles, function(pct) percent(pct, res$pop))))\n  )\n  \n  p <- ggplot(plot_data, aes(x = value, y = time, color = as.factor(percentile))) +\n    geom_line() +\n    labs(title = \"Percentile Plots Over Time\", x = \"Wealth\", y = \"Time\", color = \"Percentile\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(color = \"grey\")) +\n    scale_y_reverse()  # To match the \"time goes bottom to top\" behavior\n  print(p)\n  \n  # Histograms\n  start_hist <- ggplot(data.frame(start_population), aes(x = start_population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Start Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  final_population <- results[[length(results)]]$pop\n  final_hist <- ggplot(data.frame(final_population), aes(x = final_population)) +\n    geom_histogram(bins = 30, fill = \"green\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Final Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(start_hist)\n  print(final_hist)\n  \n  # Ordered Curves\n  ordered_curves <- data.frame(\n    order = 1:N,\n    start = sort(start_population),\n    end = final_population\n  )\n  \n  ggplot(ordered_curves) +\n    geom_line(aes(x = start, y = order, color = \"Start\")) +\n    geom_line(aes(x = end, y = order, color = \"End\")) +\n    labs(title = \"Ordered Curves\", x = \"Wealth\", y = \"Order\", color = \"Population\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n}\n\n\n#Run\nshow_simulation(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      t   Gini  stdev    1%   10%   50%   90%   99%\n------- ------ ------ ---- ---- ---- ---- ----\n  20000 0.49   96.9   1   11   70  226  441 \n  40000 0.49   98.4   1   11   70  232  452 \n  60000 0.50   98.5   1   11   70  227  456 \n  80000 0.50  100.2   1   11   68  235  450 \n 100000 0.50  100.3   1   10   70  235  462 \n 120000 0.51  102.0   1   10   69  232  475 \n 140000 0.50   97.7   1   10   70  232  452 \n 160000 0.49   97.6   1   10   72  225  436 \n 180000 0.49   98.6   1   11   71  226  451 \n 200000 0.49   97.9   1   12   71  228  447 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-6.png){width=672}\n:::\n:::\n\n\n\n\nokay so this was the recreation of https://github.com/norvig/pytudes/blob/main/ipynb/Economics.ipynb#js-repo-pjax-container\n\nnow i will play around with it - trying to gain insights\n\n**Idea 1:** **Introduce Minimum Wealth Threshold**\n\nIn current model, wealth can go very low (even close to zero, although I did not allow zeros since this caused issues). What happens if I set a min wealth threshold, so the poorest people can't lose their wealth beyond a certain point? This could simulate a sort of \"welfare\" system that prevents people from becoming too poor - as a first try i set 10 as the minimum wealth\n\n**Change to code**: Add condition that prevents wealth from dropping below a certain level.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n#Parameters\n\nN <- 5000        #Default size of the population\n\nMU <- 100        #Default mean of the population\n\nsigma <- MU / 5  #Standard deviation is 1/5 of the mean\n\n#Generate the population\n\npopulation <- rnorm(N, mean = MU, sd = sigma)\npopulation[population <= 0] <- 1\n\n#Create gini function\n\ngini <- function(y) {\n  y <- sort(y)     #Sort pop by wealth in asending order \n  n <- length(y)   #Number of people\n  numer <- 2 * sum((1:n) * y)  #Numerator sum of sorted values weighted by list pos\n  denom <- n * sum(y)  #Denominator total wealth of pop\n    return((numer / denom) - (n + 1) / n) #Compute gini coeffi\n}\n\n# Print initial Gini coefficient\ncat(\"Initial Gini coefficient:\", gini(population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitial Gini coefficient: 0.1121553 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Create hist of pop\n\nlibrary(ggplot2)\n\nhist_pop <- function(population, label='Population') {\n  gini_value <- round(gini(population), 2)\n  label <- paste(label, \"- Gini =\", gini_value)\n  \n  p <- ggplot(data.frame(population), aes(x = population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = label, x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(p)  \n}\n\nhist_pop(population)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Transaction: split the pot but with minimum\nrandom_split <- function(A, B, min_wealth = 10) {\n  pot <- A + B\n  if (A <= min_wealth && B <= min_wealth) return(c(min_wealth, min_wealth))\n  share <- runif(1, 0, pot)\n  return(c(max(share, min_wealth), max(pot - share, min_wealth)))\n}\n\n# Randomly select two actors\nanyone <- function(N) sample(1:N, 2)\n\n# Simulation step: Perform one transaction between two random actors\nstep_function <- function(population) {\n  indices <- anyone(length(population))\n  population[indices] <- random_split(population[indices[1]], population[indices[2]])\n  return(population)\n}\n\n# Simulate over T steps\nsimulate <- function(population, T) {\n  for (t in 1:T) {\n    population <- step_function(population)\n  }\n  return(population)\n}\n\n# Run the simulation and visualize the results\nT <- 1000  # Number of steps\nfinal_population <- simulate(population, T)\n\n# Plot final population distribution\nhist_pop(final_population, \"Final Population\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Display final Gini coefficient\ncat(\"Final Gini coefficient:\", gini(final_population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFinal Gini coefficient: 0.2109969 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Simulation Visualization\n\n# Libraries\nlibrary(dplyr)\n\n# Percentile Calculation & Results at interbvals\npercent <- function(pct, items) {\n  return(quantile(items, probs = pct / 100))\n}\n\nsimulate_collect <- function(population, T) {\n  results <- list()\n  for (t in 1:T) {\n    population <- step_function(population)\n    if (t %% (T / 10) == 0) {\n      results[[length(results) + 1]] <- list(t = t, pop = sort(population))\n    }\n  }\n  return(results)\n}\n\n#Simulation Visualization Function\nshow_simulation <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n  N <- length(population)\n  T <- k * N\n  start_population <- population\n  results <- simulate_collect(population, T)\n  \n  \n  cat(sprintf(\"%7s %6s %6s\", \"t\", \"Gini\", \"stdev\"))\n  for (pct in percentiles) {\n    cat(sprintf(\" %4d%%\", pct))\n  }\n  cat(\"\\n\")\n  cat(\"------- ------ ------\")\n  for (i in percentiles) cat(\" ----\")\n  cat(\"\\n\")\n  \n  for (result in results) {\n    pop <- result$pop\n    gini_value <- gini(pop)\n    stdev_value <- sd(pop)\n    percentile_values <- sapply(percentiles, function(pct) percent(pct, pop))\n    \n    \n    fmt <- sprintf(\"%7d %.2f %6.1f\", result$t, gini_value, stdev_value)\n    cat(fmt)\n    cat(sprintf(\"%4.0f\", percentile_values), \"\\n\")\n  }\n  \n  #Percentile plots over time\n  times <- sapply(results, function(res) res$t)\n  plot_data <- data.frame(\n    time = rep(times, each = length(percentiles)),\n    percentile = rep(percentiles, times = length(times)),\n    value = unlist(lapply(results, function(res) sapply(percentiles, function(pct) percent(pct, res$pop))))\n  )\n  \n  p <- ggplot(plot_data, aes(x = value, y = time, color = as.factor(percentile))) +\n    geom_line() +\n    labs(title = \"Percentile Plots Over Time\", x = \"Wealth\", y = \"Time\", color = \"Percentile\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(color = \"grey\")) +\n    scale_y_reverse()  # To match the \"time goes bottom to top\" behavior\n  print(p)\n  \n  # Histograms\n  start_hist <- ggplot(data.frame(start_population), aes(x = start_population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Start Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  final_population <- results[[length(results)]]$pop\n  final_hist <- ggplot(data.frame(final_population), aes(x = final_population)) +\n    geom_histogram(bins = 30, fill = \"green\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Final Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(start_hist)\n  print(final_hist)\n  \n  # Ordered Curves\n  ordered_curves <- data.frame(\n    order = 1:N,\n    start = sort(start_population),\n    end = final_population\n  )\n  \n  ggplot(ordered_curves) +\n    geom_line(aes(x = start, y = order, color = \"Start\")) +\n    geom_line(aes(x = end, y = order, color = \"End\")) +\n    labs(title = \"Ordered Curves\", x = \"Wealth\", y = \"Order\", color = \"Population\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n}\n\n\n#Run\nshow_simulation(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      t   Gini  stdev    1%   10%   50%   90%   99%\n------- ------ ------ ---- ---- ---- ---- ----\n  20000 0.48   98.3  10   12   72  232  446 \n  40000 0.48  102.1  10   12   76  241  476 \n  60000 0.49  105.2  10   12   77  247  481 \n  80000 0.49  110.6  10   12   77  260  497 \n 100000 0.49  113.2  10   12   80  270  520 \n 120000 0.50  118.6  10   12   81  270  554 \n 140000 0.49  116.8  10   12   84  280  546 \n 160000 0.48  118.1  10   13   90  276  523 \n 180000 0.48  121.7  10   14   91  283  561 \n 200000 0.49  124.6  10   15   93  292  586 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-6.png){width=672}\n:::\n:::\n\n\n\n\nokay, looking at the new results the minimum wealth idea worked - no individual is below 10 (as seen in the 1% quantile). I was expecting that the wealth distribution would also in turn become more evenly distributed. But if I am correct, the higher wealth quantiles now accumulate more wealth than they did before (without the minimum wealth: the 90th percentile starts at **226** units of wealth and ends at **228**. The 99th percentile starts at **441** and ends at **447**; with the wealth minimum: The 90th percentile starts at **232** and ends at **292**. The 99th percentile starts at **446** and ends at **586**.)\n\nIntroducing a minimum wealth threshold has some protective effect for the poorest individuals, preventing them from falling into extreme poverty. But I think now the richer individulals get even richer than without the minimum and even quicker as well - why I have no idea. The gini coefficient stays roughly the same.\n\n**Idea 2: Make the initial population more unequal and see what happens**\n\nNext, I will experiment and make the wealth distribution in the starting population more unequal, creating 100 individual that are wealthy and 4900 individuals that are poor (for how to code this I also asked chatGPT)\n\nI am expecting to see similar results as before - very high inequality and even higher wealth accumulation for the wealthy people\n\n**Change to code:** different wealth distribution, creating two groups (weatlhy: having 1000 vs poor: having 10)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nN <- 5000        # Total population size\nwealthy_count <- 100   # Number of wealthy individuals\npoor_count <- N - wealthy_count  # Number of poor individuals\n\n# Generate the population with more inequality\nwealthy_wealth <- 1000  # Wealth of the wealthy individuals\npoor_wealth <- 10       # Wealth of the poor individuals\n\n# Create the population\npopulation <- c(rep(wealthy_wealth, wealthy_count), rep(poor_wealth, poor_count))\n\n#Create gini function\n\ngini <- function(y) {\n  y <- sort(y)     #Sort pop by wealth in asending order \n  n <- length(y)   #Number of people\n  numer <- 2 * sum((1:n) * y)  #Numerator sum of sorted values weighted by list pos\n  denom <- n * sum(y)  #Denominator total wealth of pop\n    return((numer / denom) - (n + 1) / n) #Compute gini coeffi\n}\n\n# Print initial Gini coefficient using Gini() from DescTools\ncat(\"Initial Gini coefficient:\", gini(population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitial Gini coefficient: 0.6511409 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Create hist of pop\n\nlibrary(ggplot2)\n\nhist_pop <- function(population, label='Population') {\n  gini_value <- round(gini(population), 2)\n  label <- paste(label, \"- Gini =\", gini_value)\n  \n  p <- ggplot(data.frame(population), aes(x = population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = label, x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(p)  \n}\n\nhist_pop(population)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Transaction: Randomly split the pot between two actors\nrandom_split <- function(A, B) {\n  pot <- A + B\n  if (A <= 0 && B <= 0) return(c(0, 0))\n  share <- runif(1, 0, pot)\n  return(c(share, pot - share))\n}\n\n# Randomly select two actors\nanyone <- function(N) sample(1:N, 2)\n\n# Simulation step: Perform one transaction between two random actors\nstep_function <- function(population) {\n  indices <- anyone(length(population))\n  population[indices] <- random_split(population[indices[1]], population[indices[2]])\n  return(population)\n}\n\n# Simulate over T steps\nsimulate <- function(population, T) {\n  for (t in 1:T) {\n    population <- step_function(population)\n  }\n  return(population)\n}\n\n# Run the simulation and visualize the results\nT <- 1000  # Number of steps\nfinal_population <- simulate(population, T)\n\n# Plot final population distribution\nhist_pop(final_population, \"Final Population\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Display final Gini coefficient\ncat(\"Final Gini coefficient:\", gini(final_population), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFinal Gini coefficient: 0.6993424 \n```\n\n\n:::\n\n```{.r .cell-code}\n#Simulation Visualization\n\n# Libraries\nlibrary(dplyr)\n\n# Percentile Calculation & Results at interbvals\npercent <- function(pct, items) {\n  return(quantile(items, probs = pct / 100))\n}\n\nsimulate_collect <- function(population, T) {\n  results <- list()\n  for (t in 1:T) {\n    population <- step_function(population)\n    if (t %% (T / 10) == 0) {\n      results[[length(results) + 1]] <- list(t = t, pop = sort(population))\n    }\n  }\n  return(results)\n}\n\n#Simulation Visualization Function\nshow_simulation <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n  N <- length(population)\n  T <- k * N\n  start_population <- population\n  results <- simulate_collect(population, T)\n  \n  \n  cat(sprintf(\"%7s %6s %6s\", \"t\", \"Gini\", \"stdev\"))\n  for (pct in percentiles) {\n    cat(sprintf(\" %4d%%\", pct))\n  }\n  cat(\"\\n\")\n  cat(\"------- ------ ------\")\n  for (i in percentiles) cat(\" ----\")\n  cat(\"\\n\")\n  \n  for (result in results) {\n    pop <- result$pop\n    gini_value <- gini(pop)\n    stdev_value <- sd(pop)\n    percentile_values <- sapply(percentiles, function(pct) percent(pct, pop))\n    \n    \n    fmt <- sprintf(\"%7d %.2f %6.1f\", result$t, gini_value, stdev_value)\n    cat(fmt)\n    cat(sprintf(\"%4.0f\", percentile_values), \"\\n\")\n  }\n  \n  #Percentile plots over time\n  times <- sapply(results, function(res) res$t)\n  plot_data <- data.frame(\n    time = rep(times, each = length(percentiles)),\n    percentile = rep(percentiles, times = length(times)),\n    value = unlist(lapply(results, function(res) sapply(percentiles, function(pct) percent(pct, res$pop))))\n  )\n  \n  p <- ggplot(plot_data, aes(x = value, y = time, color = as.factor(percentile))) +\n    geom_line() +\n    labs(title = \"Percentile Plots Over Time\", x = \"Wealth\", y = \"Time\", color = \"Percentile\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(color = \"grey\")) +\n    scale_y_reverse()  # To match the \"time goes bottom to top\" behavior\n  print(p)\n  \n  # Histograms\n  start_hist <- ggplot(data.frame(start_population), aes(x = start_population)) +\n    geom_histogram(bins = 30, fill = \"blue\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Start Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  final_population <- results[[length(results)]]$pop\n  final_hist <- ggplot(data.frame(final_population), aes(x = final_population)) +\n    geom_histogram(bins = 30, fill = \"green\", color = \"black\", alpha = 0.5) +\n    labs(title = \"Final Population Histogram\", x = \"Wealth\", y = \"Count\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n  \n  print(start_hist)\n  print(final_hist)\n  \n  # Ordered Curves\n  ordered_curves <- data.frame(\n    order = 1:N,\n    start = sort(start_population),\n    end = final_population\n  )\n  \n  ggplot(ordered_curves) +\n    geom_line(aes(x = start, y = order, color = \"Start\")) +\n    geom_line(aes(x = end, y = order, color = \"End\")) +\n    labs(title = \"Ordered Curves\", x = \"Wealth\", y = \"Order\", color = \"Population\") +\n    theme_minimal() +\n    theme(panel.grid.major = element_line(colour = \"grey\"))\n}\n\n\n#Run\nshow_simulation(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      t   Gini  stdev    1%   10%   50%   90%   99%\n------- ------ ------ ---- ---- ---- ---- ----\n  20000 0.61   50.4   0    2   15   68  229 \n  40000 0.51   31.5   0    3   21   68  148 \n  60000 0.50   29.5   0    3   21   69  135 \n  80000 0.50   29.7   0    3   21   70  137 \n 100000 0.50   29.3   0    3   21   69  132 \n 120000 0.50   30.0   0    3   20   69  136 \n 140000 0.50   29.5   0    3   21   70  136 \n 160000 0.50   29.5   0    3   21   69  138 \n 180000 0.49   29.1   0    3   21   67  132 \n 200000 0.50   29.8   0    3   21   68  134 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-6.png){width=672}\n:::\n:::\n\n\n\n\nLooking at the difference between this simulation and the first, here the initial Gini coefficient is much higher compared. I think this suggests, that the wealth distribution at the beginning is much more unequal  - which is exactly what I wanted. After 20000 simulations it drops and stabilizes at around 0.51, suggesting that the system equalizes the wealth over time (a little bit at least - unequality is still high).\n\nThe 99th percentile drops significantly (from 229 to 134), indicating that the wealthiest individuals are losing wealth over time. However, they remain far richer than the rest of the population, which suggests that the random wealth transfers aren't sufficient to equalize wealth entirely. I guess with the super high amount of inequality I created this is not very surprising.\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}